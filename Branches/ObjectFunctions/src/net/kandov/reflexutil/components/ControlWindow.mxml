<?xml version="1.0" encoding="utf-8"?>
<!--
/*
*	Copyright 2007 Alon Kandov (kandov@gmail.com)
*	ReflexUtil <http://reflexutil.googlecode.com>
*	
*	==========================================================================
*	
*	This file is part of ReflexUtil.
*	
*	ReflexUtil is free software: you can redistribute it and/or modify
*	it under the terms of the GNU General Public License as published by
*	the Free Software Foundation, either version 3 of the License, or
*	(at your option) any later version.
*	
*	ReflexUtil is distributed in the hope that it will be useful,
*	but WITHOUT ANY WARRANTY; without even the implied warranty of
*	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*	GNU General Public License for more details.
*	
*	You should have received a copy of the GNU General Public License
*	along with ReflexUtil.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<window:SizeableTitleWindow xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:window="com.adobe.ColdFusion.components.*"
	showCloseButton="true" close="hide()" title="{'ReflexUtil (Version ' + ReflexUtil.VERSION + ')'}"
	creationComplete="creationCompleteHandler()" xmlns:components="net.kandov.reflexutil.components.*">
	
	<mx:Metadata>
		[Event(type="flash.events.Event", name="applicationChanged")]
		[Event(type="flash.events.Event", name="showingChanged")]
	</mx:Metadata>
	
	<mx:Script>
		<![CDATA[
			import mx.managers.CursorManager;
			import mx.core.IFlexDisplayObject;
			import mx.events.CloseEvent;
			import mx.graphics.codec.PNGEncoder;
			import mx.states.SetStyle;
			import net.kandov.reflexutil.utils.ClassUtil;
			import mx.controls.ComboBase;
			import mx.controls.Alert;
			import mx.collections.ArrayCollection;
			import mx.collections.Sort;
			import mx.collections.SortField;
			import mx.controls.treeClasses.TreeItemRenderer;
			import mx.core.Application;
			import mx.core.UIComponent;
			import mx.events.ListEvent;
			import mx.managers.PopUpManager;
			import mx.managers.SystemManager;
			import flash.net.FileReference;
			
			import net.kandov.reflexutil.assets.Images;
			import net.kandov.reflexutil.ReflexUtil;
			import net.kandov.reflexutil.utils.ComponentUtil;
			import net.kandov.reflexutil.types.ComponentInfo;
			import net.kandov.reflexutil.types.PropertyInfo;
			import net.kandov.reflexutil.types.PropertyTypes;
			
			private var _application:Application;
			private var _componentsInfos:ArrayCollection = new ArrayCollection();
			private var _treeComponentsInfosContextMenu:ContextMenu = new ContextMenu();
			private var _selectedComponentInfo:ComponentInfo;
			private var _hoveredComponentInfo:ComponentInfo;
			private var _propertiesInfos:ArrayCollection = new ArrayCollection();
			private var alreadyShowed:Boolean;
			private var componentHover:ComponentHover = new ComponentHover();
			private var propertiesInfosDefaultSort:Sort = new Sort();
			private var bitmap:Bitmap;
			
			[Bindable]
			private var isDrawing:Boolean = false;
			[Bindable]
			private var x1:int;
			[Bindable]
			private var y1:int;
			[Bindable]
			private var x2:int;
			[Bindable]
			private var y2:int;
			[Bindable]
			private var drawColor:uint;
			
			[Embed(source="../assets/colorPicker.png")]
			public static var colorPickerCursor:Class;
			
			private var cursorID:int;
	
			[Bindable]
            public var objectOptionsCollection:ArrayCollection = new ArrayCollection(
                [ {label:"", handlerFunction:doNothingHandler}, 
                  {label:"Hide Object", handlerFunction:hideObjectHandler}, 
                  {label:"Show Object", handlerFunction:showObjectHandler}, 
                  {label:"Move Object", handlerFunction:moveObjectHandler}, 
                  {label:"Duplicate Object", handlerFunction:duplicateObjectHandler}, 
                  {label:"Remove Object From Layout", handlerFunction:removeObjectFromLayoutHandler},
                  {label:"Add Object To Layout", handlerFunction:addObjectToLayoutHandler},
                  {label:"Add Event Listener To Object", handlerFunction:addEventListenerToObjectHandler},
                  {label:"Run Function on Object", handlerFunction:runFuntionOnObjectHandler},
                  {label:"Goto Object Parent", handlerFunction:gotoObjectParentHandler},
                  {label:"SetStyle to Object", handlerFunction:setStyleToObjectHandler} ]);
			[Bindable]
            public var globalOptionsCollection:ArrayCollection = new ArrayCollection(
                [ {label:"", handlerFunction:doNothingHandler},
                  {label:"Hide Object", handlerFunction:hideObjectHandler}, 
                  {label:"Move Object", handlerFunction:hideObjectHandler}, 
                  {label:"Remove Object From Layout", handlerFunction:removeObjectFromLayoutHandler},
                  {label:"Add Object To Layout", handlerFunction:addObjectToLayoutHandler} ]);

			//--------------------------------------------------------------------------
			// interface
			//--------------------------------------------------------------------------
			
			[Bindable(event="applicationChanged")]
			public function get application():Application {
				return _application;
			}
			
			public function set application(value:Application):void {
				if (_application != value) {
					_application = value;
					dispatchEvent(new Event("applicationChanged"));
				}
			}
			
			[Bindable(event="showingChanged")]
			public function get showing():Boolean {
				return isPopUp;
			}
			
			public function show():void {
				if (!showing) {
					PopUpManager.addPopUp(this, application);
					dispatchEvent(new Event("showingChanged"));
					
					if ((x == -1 || y == -1) && !alreadyShowed) {
						PopUpManager.centerPopUp(this);
						alreadyShowed = true;
					}
				}
			}
			
			public function hide():void {
				if (showing) {
					PopUpManager.removePopUp(this);
					dispatchEvent(new Event("showingChanged"));
				}
			}
			
			public function addComponent(component:DisplayObjectContainer):void {
				var newComponentInfo:ComponentInfo = ComponentUtil.generateComponentInfo(component);
				
				var containsComponentInfo:Boolean = false;
				for each (var componentInfo:ComponentInfo in componentsInfos) {
					if (componentInfo.equals(newComponentInfo)) {
						containsComponentInfo = true;
						break;
					}
				}
				
				if (!containsComponentInfo) {
					componentsInfos.addItem(newComponentInfo);
				}
				
				selectedComponentInfo = newComponentInfo;
			}
			
			//--------------------------------------------------------------------------
			// private
			//--------------------------------------------------------------------------
			
			[Bindable(event="componentsInfosChanged")]
			private function get componentsInfos():ArrayCollection {
				return _componentsInfos;
			}
			
			private function set componentsInfos(value:ArrayCollection):void {
				if (_componentsInfos != value) {
					_componentsInfos = value;
					dispatchEvent(new Event("componentsInfosChanged"));
				}
			}
			
			[Bindable(event="treeComponentsInfosContextMenuChanged")]
			private function get treeComponentsInfosContextMenu():ContextMenu {
				return _treeComponentsInfosContextMenu;
			}
			
			private function set treeComponentsInfosContextMenu(value:ContextMenu):void {
				if (_treeComponentsInfosContextMenu != value) {
					_treeComponentsInfosContextMenu = value;
					dispatchEvent(new Event("treeComponentsInfosContextMenuChanged"));
				}
			}
			
			[Bindable(event="selectedComponentInfoChanged")]
			private function get selectedComponentInfo():ComponentInfo {
				return _selectedComponentInfo;
			}
			
			private function set selectedComponentInfo(value:ComponentInfo):void {
				if (_selectedComponentInfo != value) {
					if (value) {
						setPropertiesInfosSource(value.propertiesInfos);
					} else {
						setPropertiesInfosSource(null);
					}
					
					_selectedComponentInfo = value;
					dispatchEvent(new Event("selectedComponentInfoChanged"));
				}
			}
			
			[Bindable(event="hoveredComponentInfoChanged")]
			private function get hoveredComponentInfo():ComponentInfo {
				return _hoveredComponentInfo;
			}
			
			private function set hoveredComponentInfo(value:ComponentInfo):void {
				if (_hoveredComponentInfo != value) {
					if (_hoveredComponentInfo) {
						componentHover.hide();
					}
					
					if (value) {
						componentHover.show(value.component);
					}
					
					_hoveredComponentInfo = value;
					dispatchEvent(new Event("hoveredComponentInfoChanged"));
				}
			}
			
			[Bindable(event="propertiesInfosChanged")]
			private function get propertiesInfos():ArrayCollection {
				return _propertiesInfos;
			}
			
			private function setPropertiesInfosSource(source:Array):void {
				if (_propertiesInfos.source != source) {
					_propertiesInfos.source = source;
					dispatchEvent(new Event("propertiesInfosChanged"));
				}
			}
			
			private function removeComponentInfo(componentInfo:ComponentInfo):void {
				var rootComponentInfo:ComponentInfo = ComponentUtil.getRootComponentInfo(componentInfo);
				var index:int = componentsInfos.getItemIndex(rootComponentInfo);
				if (index != -1) {
					componentsInfos.removeItemAt(index);
					
					if (ComponentUtil.getRootComponentInfo(hoveredComponentInfo) == rootComponentInfo) {
						hoveredComponentInfo = null;
					}
					
					if (index < componentsInfos.length) {
						selectedComponentInfo = componentsInfos[index];
					} else if (index != 0) {
						selectedComponentInfo = componentsInfos[index - 1];
					} else {
						selectedComponentInfo = null;
					}
				}
			}
			
			private function filterPropertiesInfos(item:Object):Boolean {
				var propertyInfo:PropertyInfo = PropertyInfo(item);
				
				var filterType:int = int(cmbPropertiesFilterType.selectedItem.data);
				var propertyIsStyle:Boolean = propertyInfo.isStyle;
				if ((filterType == PropertyTypes.PROPERTY && propertyIsStyle) ||
					(filterType == PropertyTypes.STYLE && !propertyIsStyle)) {
					return false;
				}
				
				var filterName:String = txtPropertiesFilterName.text.toLowerCase();
				var propertyName:String = propertyInfo.name.toLowerCase();
				var filters:Array = filterName.split("|");
				var match:Boolean = false;
				for each (var filter:String in filters) {
					if (propertyName.indexOf(filter) != -1) {
						match = true;
					}
				}
				
				return match;
			}
			
			//--------------------------------------------------------------------------
			// handlers
			//--------------------------------------------------------------------------
			
			private function creationCompleteHandler():void {
				application.addChild(componentHover);
				
				treeComponentsInfosContextMenu.hideBuiltInItems();
				treeComponentsInfosContextMenu.addEventListener(ContextMenuEvent.MENU_SELECT,
					treeComponentsInfosContextMenuSelectHandler, false, 0, true);
				
				propertiesInfosDefaultSort.fields = [new SortField("name")];
				propertiesInfos.sort = propertiesInfosDefaultSort;
				propertiesInfos.filterFunction = filterPropertiesInfos;
				propertiesInfos.refresh();
				dispatchEvent(new Event("propertiesInfosChanged"));
			}
			
			private function treeComponentsInfosMouseMoveHandler(event:MouseEvent):void {
				//ListEvent.ITEM_ROLL_OVER and ListEvent.ITEM_ROLL_OUT are buggy when using ContextMenu
				var itemRenderer:TreeItemRenderer = InteractiveObject(event.target).parent as TreeItemRenderer;
				if (itemRenderer) {
					hoveredComponentInfo = ComponentInfo(itemRenderer.data);
				} else {
					hoveredComponentInfo = null;
				}
			}
			
			private function treeComponentsInfosContextMenuSelectHandler(event:ContextMenuEvent):void {
				treeComponentsInfosContextMenu.customItems = new Array();
				if (hoveredComponentInfo) {
					selectedComponentInfo = hoveredComponentInfo;
					
					var rootComponentInfo:ComponentInfo = ComponentUtil.getRootComponentInfo(hoveredComponentInfo);
					var removeMenuItem:ContextMenuItem = new ContextMenuItem(
						"Remove [" + ComponentUtil.getUID(rootComponentInfo.component) + "]");
					removeMenuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT,
						removeMenuItemSelectHandler, false, 0, true);
					treeComponentsInfosContextMenu.customItems.push(removeMenuItem);
				}
			}
			
			private function removeMenuItemSelectHandler(event:ContextMenuEvent):void {
				removeComponentInfo(hoveredComponentInfo);
			}
			
			private function treeComponentsInfosKeyDownHandler(event:KeyboardEvent):void {
				if (event.keyCode == Keyboard.DELETE) {
					removeComponentInfo(ComponentInfo(treeComponentsInfos.selectedItem));
				}
			}
			
			private function btnRefreshPropertiesInfosClickHandler():void {
				if (propertiesInfos) {
					for each (var propertyInfo:PropertyInfo in propertiesInfos) {
						ComponentUtil.getPropertyValue(propertyInfo);
					}
				}
			}
			
			private function doNothingHandler(...arg):void {
				
			}
			private function hideObjectHandler(...arg):void {
				if(selectedComponentInfo && selectedComponentInfo.component && hasOwnProperty('visible')){
					selectedComponentInfo.component['visible'] = false;
				}
			}
			private function showObjectHandler(...arg):void {
				if(selectedComponentInfo && selectedComponentInfo.component && hasOwnProperty('visible')){
					selectedComponentInfo.component['visible'] = true;
				}
			}
			private function moveObjectHandler(...arg):void {
				 if(selectedComponentInfo && selectedComponentInfo.component ){
				 	stage.addChild(selectedComponentInfo.component as UIComponent);
					application.addEventListener(MouseEvent.MOUSE_MOVE, drageObjectHandler,false,0,true);
				} 
			}
			private function duplicateObjectHandler(...arg):void {
				 if(selectedComponentInfo && selectedComponentInfo.component ){
					var newUIObject:UIComponent = ClassUtil.clone(selectedComponentInfo.component) as UIComponent;
				 	if(newUIObject && selectedComponentInfo.component.parent) {
				 		selectedComponentInfo.component.parent.addChild(newUIObject);
				 	}
				 	
				} 
			}
			private function removeObjectFromLayoutHandler(...arg):void {
				if(selectedComponentInfo && selectedComponentInfo.component && hasOwnProperty('visible')){
					selectedComponentInfo.component['includeInLayout'] = false;
				}
			}
			private function addObjectToLayoutHandler(...arg):void {
				if(selectedComponentInfo && selectedComponentInfo.component && hasOwnProperty('visible')){
					selectedComponentInfo.component['includeInLayout'] = true;
				}
			}
			private function addEventListenerToObjectHandler(...arg):void {
				if(selectedComponentInfo && selectedComponentInfo.component && hasOwnProperty('visible')){
				}
			}
			private function runFuntionOnObjectHandler(...arg):void {
				if(selectedComponentInfo && selectedComponentInfo.component && hasOwnProperty('visible')){
					/* var s:String = 'function a() { Alert.show();}';
					var f:Function = s as Function;
					if(f != null) {
						f.call(this);
					} */
				} 
			}
			
			private function gotoObjectParentHandler(...arg):void {
				if(selectedComponentInfo && selectedComponentInfo.component && hasOwnProperty('parent') && selectedComponentInfo.component['parent']){
					var p:DisplayObjectContainer = selectedComponentInfo.component['parent'] as DisplayObjectContainer;
					if(p) {
						addComponent(p)
					}
				}
			}
			private function setStyleToObjectHandler(...arg):void {
				if(selectedComponentInfo && selectedComponentInfo.component && hasOwnProperty('visible')){
					var setStyleEditor:SetStyleEditor = new SetStyleEditor();
					setStyleEditor.data = selectedComponentInfo;
					PopUpManager.addPopUp(setStyleEditor,application as DisplayObject);
					setStyleEditor.addEventListener(CloseEvent.CLOSE, windowCloseHandler, false, 0, true);
					PopUpManager.centerPopUp(setStyleEditor);
				}
			}
			
			private function comboObjectOptionsChangeHandler(e:ListEvent):void {
				var cb:ComboBox = e.currentTarget as ComboBox;
				if(cb && cb.selectedItem && cb.selectedItem.handlerFunction != null){
					var f:Function = cb.selectedItem.handlerFunction as Function;
					f.call(this,null);
					
				}
				
			}
			
			private function btnExecuteObjectOptionsHandler():void {
				var cb:ComboBox = comboObjectOptions;
				if(cb && cb.selectedItem && cb.selectedItem.handlerFunction != null){
					var f:Function = cb.selectedItem.handlerFunction as Function;
					f.call(this,null);
					
				}
			}
			
			private function hideOverlayLayoutHandler():void {
				componentHover.visible = !chkHideOverlayLayout.selected;
			}
			
			private function exportToFlexHandler():void {
				/* var valueDescriptor:ValueDescriptor = new ValueDescriptor();
				valueDescriptor.data = selectedComponentInfo;
				PopUpManager.addPopUp(setStyleEditor,application as DisplayObject);
				setStyleEditor.addEventListener(CloseEvent.CLOSE, windowCloseHandler, false, 0, true);
				PopUpManager.centerPopUp(setStyleEditor);	 */
			}
			
			private function drageObjectHandler(e:MouseEvent):void {
				if(e.altKey){
					selectedComponentInfo.component.x = e.stageX;
					selectedComponentInfo.component.y = e.stageY;
				}
			}
			
			private function picColorClickHandler():void {
				if(stage && application) { 
					var bitmapData:BitmapData = new BitmapData(stage.width, stage.height);  
					bitmapData.draw(stage);    
					bitmap = new Bitmap(bitmapData);
					cursorID = CursorManager.setCursor(colorPickerCursor,2,-6,-6);
					application.addEventListener(MouseEvent.MOUSE_DOWN, stagePicColorHandler,false,0,true);
					//stage.addEventListener(KeyboardEvent.KEY_DOWN,keybordHandler,false,0,true);
				}
			}
			
			private function stagePicColorHandler(e:MouseEvent):void {
				var colorUnderTheMouse:uint;
				CursorManager.removeCursor(cursorID);
				if(stage) {
					colorUnderTheMouse = bitmap.bitmapData.getPixel(e.stageX,e.stageY);
					colorCanvas.setStyle('backgroundColor', colorUnderTheMouse);
					lblColor.text = '#' + colorUnderTheMouse.toString(16);
					bitmap = null;
					application.removeEventListener(MouseEvent.MOUSE_DOWN,stagePicColorHandler);
				}
			}
			
			private function keybordHandler(e:KeyboardEvent):void {
				if(e.keyCode) {
					bitmap = null;
					application.removeEventListener(MouseEvent.MOUSE_MOVE,stagePicColorHandler);
					//stage.removeEventListener(KeyboardEvent.KEY_DOWN,keybordHandler);
				}
			}
			private function btnToolBarHandler():void {
				if(btnToolBar.selected){
					currentState = 'toolBarOpen_State';
				} else {
					currentState = '';
				}
				btnToolBar.selected = !btnToolBar.selected
			}
			
			private function mouseDownDrawHandler(e:MouseEvent):void {
				 x1 = e.stageX;
			     y1 = e.stageY;
			     isDrawing = true;
			}
			private function mouseMoveDrawHandler(e:MouseEvent):void {
				 x2 = e.stageX;
			     y2 = e.stageY;
			     if (isDrawing)
			     {
			        drawingCanvas.graphics.lineStyle(2, drawColor);
			        drawingCanvas.graphics.moveTo(x1, y1);
			        drawingCanvas.graphics.lineTo(x2, y2);
			        x1 = x2;
			        y1 = y2;
			     }
			}
			private function mouseUpDrawHandler(e:MouseEvent):void {
				 isDrawing = false;
			}
			
			private function btnStartDrawHandler():void {
				/* var c:Canvas = new Canvas();
				c.width = application.width;
				c.height = application.height; */
					
				if(btnStartDraw.selected){
					//PopUpManager.addPopUp(drawingCanvas,application as DisplayObject);
					//drawingCanvas.addEventListener(CloseEvent.CLOSE, windowCloseHandler, false, 0, true);
					application.addChild(drawingCanvas);
				} else {
					//drawingCanvas.dispatchEvent(new CloseEvent(CloseEvent.CLOSE));
					application.removeChild(drawingCanvas);
				}
				
				/* if(btnStartDraw.selected){
					application.addEventListener(MouseEvent.MOUSE_DOWN , mouseDownDrawHandler,false,0,true);
					application.addEventListener(MouseEvent.MOUSE_MOVE , mouseMoveDrawHandler,false,0,true);
					application.addEventListener(MouseEvent.MOUSE_UP , mouseUpDrawHandler,false,0,true);
				} else {
					application.removeEventListener(MouseEvent.MOUSE_DOWN , mouseDownDrawHandler);
					application.removeEventListener(MouseEvent.MOUSE_MOVE , mouseMoveDrawHandler);
					application.removeEventListener(MouseEvent.MOUSE_UP , mouseUpDrawHandler);
				} */
			}
			
			private function btnSaveHandler():void {
			    var bd:BitmapData = new BitmapData(application.width,application.height);
		        bd.draw(application);
		  
		        var ba:ByteArray = (new PNGEncoder()).encode(bd);
		        var fr:FileReference = new FileReference();
		        fr.save(ba, "screenShot.png");
			}
			
			private function windowCloseHandler(e:CloseEvent):void {
				var popUp:IFlexDisplayObject = IFlexDisplayObject(e.currentTarget);
				PopUpManager.removePopUp(popUp);
			}
			
			private function gotoObjectParentClickedHandler():void {
				gotoObjectParentHandler();
			}
			private function showHideIconClickedHandler():void {
				if(selectedComponentInfo && selectedComponentInfo.component) {
					if(selectedComponentInfo.component.visible) {
						hideObjectHandler();
					} else {
						showObjectHandler();
					}
				}
			}
		]]>
	</mx:Script>
	
	<mx:Array>
		<mx:Canvas id="drawingCanvas" width="{application.width}" height="{application.height}" horizontalScrollPolicy="off" verticalScrollPolicy="off"
			mouseUp="mouseUpDrawHandler(event)"
			mouseMove="mouseMoveDrawHandler(event)"
			mouseDown="mouseDownDrawHandler(event)"
			/>

	</mx:Array>
	
	<window:states>
		<mx:State name="toolBarOpen_State">
			<mx:AddChild relativeTo="{vbox1}" position="after">
				<mx:VBox id="toolbarBox"  borderStyle="solid" borderThickness="1">
					<mx:VBox  borderStyle="solid" borderThickness="1">
						 <mx:ColorPicker change="drawColor = event.target.selectedColor"/>
					     <mx:Button label="Erase" click="{application.graphics.clear()}" />
					     <mx:Button label="Save Image" click="btnSaveHandler()"/>
					     <mx:Button id="btnStartDraw" label="Start draw" click="btnStartDrawHandler()" toggle="true"/>
					</mx:VBox>
					<mx:VBox  borderStyle="solid" borderThickness="1">
						<mx:Canvas width="30" height="20" id="colorCanvas" backgroundAlpha="1" />
						<mx:Label id="lblColor" width="100" selectable="true" text="#ffffff" />
						<mx:Button label="Pick Color" id="btnPicColor" click="picColorClickHandler()"/>
					</mx:VBox>
				</mx:VBox>
			</mx:AddChild>
			
		</mx:State>
	</window:states>
	
	<mx:HBox id="mainHBox" width="100%" height="100%">
		<mx:VBox width="100%" height="100%" id="vbox1">
		
			<mx:VDividedBox width="100%" height="100%">
				
				<!-- FIXME: selectedIndex doesn't always refresh when inspecting when window is hidden -->
				<components:ComponentTree id="treeComponentsInfos" width="100%" height="30%" dataProvider="{componentsInfos}"
					selectedIndex="{componentsInfos.getItemIndex(selectedComponentInfo)}"
					contextMenu="{treeComponentsInfosContextMenu}"
					gotoParentObjectIconClicked="gotoObjectParentClickedHandler()"
					showHideIconClicked="showHideIconClickedHandler()"
					change="selectedComponentInfo = ComponentInfo(event.itemRenderer.data)"
					keyDown="treeComponentsInfosKeyDownHandler(event)"
					mouseMove="treeComponentsInfosMouseMoveHandler(event)"
					itemRenderer="{new ClassFactory(ComponentInfoItemRenderer)}"/>
				<mx:VBox width="100%" height="70%">
					<mx:HBox width="100%" horizontalGap="2" verticalAlign="middle">
						<mx:Label text="Type:"/>
						<mx:ComboBox id="cmbPropertiesFilterType" width="100" change="propertiesInfos.refresh()">
							<mx:dataProvider>
								<mx:Array>
									<mx:Object label="All" data="{PropertyTypes.ALL}"/>
									<mx:Object label="Properties" data="{PropertyTypes.PROPERTY}"/>
									<mx:Object label="Styles" data="{PropertyTypes.STYLE}"/>
								</mx:Array>
							</mx:dataProvider>
						</mx:ComboBox>
						<mx:Spacer width="10"/>
						<mx:Label text="Name:"/>
						<mx:TextInput id="txtPropertiesFilterName" width="100%" change="propertiesInfos.refresh()"/>
						<mx:Image id="btnRefreshPropertiesInfos" source="{Images.REFRESH}"
							toolTip="Refresh all not bindable properties"
							buttonMode="true" click="btnRefreshPropertiesInfosClickHandler()"/>
					</mx:HBox>
					<mx:DataGrid id="dgPropertiesInfos" width="100%" height="100%" dataProvider="{propertiesInfos}"
						alternatingItemColors="#ffffff" horizontalGridLines="true" horizontalGridLineColor="#cccccc">
						<mx:columns>
							<mx:DataGridColumn headerText="Name" dataField="name"/>
							<mx:DataGridColumn headerText="Value" dataField="value" sortable="false"
								itemRenderer="{new ClassFactory(ValueEditor)}">
							</mx:DataGridColumn>
						</mx:columns>
					</mx:DataGrid>
				</mx:VBox>
			</mx:VDividedBox>
		</mx:VBox>
	</mx:HBox>
	
	<mx:ControlBar id="controlbar1">
	<mx:VBox width="100%">
		<mx:HBox width="100%">
			<mx:CheckBox id="chkHideOverlayLayout" label="hide/show Overlay Layout" toolTip="hide/show Overlay Layout" change="hideOverlayLayoutHandler()"/>
			<mx:Button id="btnExportToText" label="Export to text" click="exportToFlexHandler()"/>
			<mx:Button id="btnToolBar" label="Open Toolbar" toggle="true" click="btnToolBarHandler()"/>
			
		</mx:HBox>
		<!--<mx:Button label="Move Object" click="moveObjectHandler()" />-->
		<mx:HBox width="100%">
			<mx:ComboBox id="comboObjectOptions" dataProvider="{objectOptionsCollection}"
				/>
			<mx:Button id="btnExecute" label="Execute Object Options" click="btnExecuteObjectOptionsHandler()"/>
		</mx:HBox>
		<!--<mx:ComboBox id="comboGlobalOptions" dataProvider="{globalOptionsCollection}"
			change="comboObjectOptionsChangeHandler(event)"/>-->
		
	</mx:VBox>
	</mx:ControlBar>
</window:SizeableTitleWindow>
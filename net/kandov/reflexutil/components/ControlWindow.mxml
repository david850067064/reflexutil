<?xml version="1.0" encoding="utf-8"?>
<window:SizeableTitleWindow xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:window="com.adobe.ColdFusion.components.*"
	showCloseButton="true" close="hide()" title="ReflexUtil"
	creationComplete="creationCompleteHandler()">
	
	<mx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.collections.Sort;
			import mx.collections.SortField;
			import mx.core.Application;
			import mx.core.UIComponent;
			import mx.events.ListEvent;
			import mx.managers.PopUpManager;
			import mx.managers.SystemManager;
			import net.kandov.reflexutil.types.ComponentInfo;
			import net.kandov.reflexutil.utils.ComponentUtil;
			import net.kandov.reflexutil.types.PropertyInfo;
			
			private var _application:Application;
			private var _componentsInfos:ArrayCollection = new ArrayCollection();
			private var _treeComponentsInfosContextMenu:ContextMenu = new ContextMenu();
			private var _selectedComponentInfo:ComponentInfo;
			private var _hoveredComponentInfo:ComponentInfo;
			private var _propertiesInfos:ArrayCollection;
			private var alreadyShowed:Boolean;
			private var componentHover:ComponentHover = new ComponentHover();
			
			//--------------------------------------------------------------------------
			// interface
			//--------------------------------------------------------------------------
			
			[Bindable(event="applicationChanged")]
			public function get application():Application {
				return _application;
			}
			
			public function set application(value:Application):void {
				if (_application != value) {
					_application = value;
					dispatchEvent(new Event("applicationChanged"));
				}
			}
			
			[Bindable(event="showingChanged")]
			public function get showing():Boolean {
				return isPopUp;
			}
			
			public function show():void {
				if (!showing) {
					PopUpManager.addPopUp(this, Application(Application.application));
					dispatchEvent(new Event("showingChanged"));
					
					if ((x == -1 || y == -1) && !alreadyShowed) {
						PopUpManager.centerPopUp(this);
						alreadyShowed = true;
					}
				}
			}
			
			public function hide():void {
				if (showing) {
					PopUpManager.removePopUp(this);
					dispatchEvent(new Event("showingChanged"));
				}
			}
			
			public function addComponent(component:UIComponent):void {
				var newComponentInfo:ComponentInfo = ComponentUtil.generateComponentInfo(component);
				
				var containsComponentInfo:Boolean = false;
				for each (var componentInfo:ComponentInfo in componentsInfos) {
					if (componentInfo.equals(newComponentInfo)) {
						containsComponentInfo = true;
						break;
					}
				}
				
				if (!containsComponentInfo) {
					componentsInfos.addItem(newComponentInfo);
				}
			}
			
			//--------------------------------------------------------------------------
			// private
			//--------------------------------------------------------------------------
			
			[Bindable(event="componentsInfosChanged")]
			private function get componentsInfos():ArrayCollection {
				return _componentsInfos;
			}
			
			private function set componentsInfos(value:ArrayCollection):void {
				if (_componentsInfos != value) {
					_componentsInfos = value;
					dispatchEvent(new Event("componentsInfosChanged"));
				}
			}
			
			[Bindable(event="treeComponentsInfosContextMenuChanged")]
			private function get treeComponentsInfosContextMenu():ContextMenu {
				return _treeComponentsInfosContextMenu;
			}
			
			private function set treeComponentsInfosContextMenu(value:ContextMenu):void {
				if (_treeComponentsInfosContextMenu != value) {
					_treeComponentsInfosContextMenu = value;
					dispatchEvent(new Event("treeComponentsInfosContextMenuChanged"));
				}
			}
			
			[Bindable(event="selectedComponentInfoChanged")]
			private function get selectedComponentInfo():ComponentInfo {
				return _selectedComponentInfo;
			}
			
			private function set selectedComponentInfo(value:ComponentInfo):void {
				treeComponentsInfos.selectedItem = value;
				
				if (_selectedComponentInfo != value) {
					if (value) {
						propertiesInfos = ComponentUtil.generatePropertiesInfos(value.component);
					} else {
						propertiesInfos = null;
					}
					
					_selectedComponentInfo = value;
					dispatchEvent(new Event("selectedComponentInfoChanged"));
				}
			}
			
			[Bindable(event="hoveredComponentInfoChanged")]
			private function get hoveredComponentInfo():ComponentInfo {
				return _hoveredComponentInfo;
			}
			
			private function set hoveredComponentInfo(value:ComponentInfo):void {
				if (_hoveredComponentInfo != value) {
					if (_hoveredComponentInfo) {
						componentHover.hide();
					}
					
					if (value) {
						componentHover.show(value.component);
					}
					
					_hoveredComponentInfo = value;
					dispatchEvent(new Event("hoveredComponentInfoChanged"));
				}
			}
			
			[Bindable(event="propertiesInfosChanged")]
			private function get propertiesInfos():ArrayCollection {
				return _propertiesInfos;
			}
			
			private function set propertiesInfos(value:ArrayCollection):void {
				if (_propertiesInfos != value) {
					var sort:Sort;
					var filter:Function;
					
					if (_propertiesInfos) {
						sort = _propertiesInfos.sort;
						filter = _propertiesInfos.filterFunction;
					}
					
					if (value) {
						if (!sort) {
							sort = new Sort();
							sort.fields = [new SortField("name")];
						}
						
						value.sort = sort;
						value.filterFunction = filter;
						value.refresh();
					}
					
					_propertiesInfos = value;
					dispatchEvent(new Event("propertiesInfosChanged"));
				}
			}
			
			private function removeComponentInfo(componentInfo:ComponentInfo):void {
				var rootComponentInfo:ComponentInfo = ComponentUtil.getRootComponentInfo(componentInfo);
				var index:int = componentsInfos.getItemIndex(rootComponentInfo);
				if (index != -1) {
					componentsInfos.removeItemAt(index);
					
					if (ComponentUtil.getRootComponentInfo(hoveredComponentInfo) == rootComponentInfo) {
						hoveredComponentInfo = null;
					}
					
					if (index < componentsInfos.length) {
						selectedComponentInfo = componentsInfos[index];
					} else if (index != 0) {
						selectedComponentInfo = componentsInfos[index - 1];
					} else {
						selectedComponentInfo = null
					}
				}
			}
			
			private function filterPropertiesInfos(item:Object):Boolean {
				var propertyName:String = PropertyInfo(item).name.toLowerCase();
				var filterString:String = txtPropertiesFilter.text.toLowerCase();
				
				return propertyName.indexOf(filterString) == -1 ? false : true;
			}
			
			//--------------------------------------------------------------------------
			// handlers
			//--------------------------------------------------------------------------
			
			private function creationCompleteHandler():void {
				application.addChild(componentHover);
				
				treeComponentsInfosContextMenu.hideBuiltInItems();
				treeComponentsInfosContextMenu.addEventListener(ContextMenuEvent.MENU_SELECT,
					treeComponentsInfosContextMenuSelectHandler, false, 0, true);
			}
			
			private function treeComponentsInfosContextMenuSelectHandler(event:ContextMenuEvent):void {
				treeComponentsInfosContextMenu.customItems = new Array();
				if (hoveredComponentInfo) {
					selectedComponentInfo = hoveredComponentInfo;
					
					var rootComponentInfo:ComponentInfo = ComponentUtil.getRootComponentInfo(hoveredComponentInfo);
					var removeMenuItem:ContextMenuItem = new ContextMenuItem(
						"Remove [" + ComponentUtil.getUID(rootComponentInfo.component) + "]");
					removeMenuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT,
						removeMenuItemSelectHandler, false, 0, true);
					treeComponentsInfosContextMenu.customItems.push(removeMenuItem);
				}
			}
			
			private function removeMenuItemSelectHandler(event:ContextMenuEvent):void {
				removeComponentInfo(hoveredComponentInfo);
			}
			
			private function treeComponentsInfosKeyDownHandler(event:KeyboardEvent):void {
				if (event.keyCode == Keyboard.DELETE) {
					removeComponentInfo(ComponentInfo(treeComponentsInfos.selectedItem));
				}
			}
			
			private function txtFilterPropertiesChangeHandler():void {
				propertiesInfos.filterFunction = filterPropertiesInfos;
				propertiesInfos.refresh();
			}
		]]>
	</mx:Script>
	
	<mx:VBox width="100%" height="100%">
		<mx:VDividedBox width="100%" height="100%">
			<mx:Tree id="treeComponentsInfos" width="100%" height="30%" dataProvider="{componentsInfos}"
				contextMenu="{treeComponentsInfosContextMenu}" keyDown="treeComponentsInfosKeyDownHandler(event)"
				change="selectedComponentInfo = event.itemRenderer ? ComponentInfo(event.itemRenderer.data) : null"
				itemRollOver="hoveredComponentInfo = ComponentInfo(event.itemRenderer.data)"
				itemRollOut="hoveredComponentInfo = null"/>
			<mx:VBox width="100%" height="70%">
				<mx:TextInput id="txtPropertiesFilter" width="100%" change="txtFilterPropertiesChangeHandler()"/>
				<!-- FIXME: after selecting a combobox boolean value, scroller is buggy -->
				<mx:DataGrid id="dgPropertiesInfos" width="100%" height="100%" dataProvider="{propertiesInfos}">
					<mx:columns>
						<mx:DataGridColumn headerText="Property Name" dataField="name"/>
						<mx:DataGridColumn headerText="Property Value" dataField="value" sortable="false"
							itemRenderer="{new ClassFactory(ValueEditor)}">
						</mx:DataGridColumn>
					</mx:columns>
				</mx:DataGrid>
			</mx:VBox>
		</mx:VDividedBox>
	</mx:VBox>
	
</window:SizeableTitleWindow>